<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>ArrayList in Rust, part 2: Optimizing the layout | Daniel Dulaney</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>ArrayList in Rust, part 2: Optimizing the layout</span></h1><h2 class=date>2019/07/17</h2></div><main><p>At the end of <a href=../arraylist-part-1>part 1</a>, we had just about finished implementing <code>AppendList</code>, an array of arrays that let you push new elements on through an immutable reference.</p><p>It worked pretty well! There were a bunch of chunks that were all the same size, and it was pretty easy to figure out which index was in each chunk. But there&rsquo;s a downside: somebody needs to pick what chunk size to use. You could imagine this going wrong both ways: too small, and the overhead of keeping track of each chunk is pretty significant. Too big, and the unused space at the end of the last chunk is problematic.</p><p>We could just throw up our hands and let the end user pick, but that&rsquo;s not a great experience for them. We&rsquo;d have to add a chunk size parameter to the <code>new</code> function, save that parameter somewhere (with some runtime cost),<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and then reference that parameter whenever we need the chunk size.</p><p>But as a developer, being forced to choose is annoying. We could pick a reasonable default, but then everybody would just go ahead and use that default and we would be right back where we started.</p><p>But there&rsquo;s another option. When you use a <code>Vec</code>, you don&rsquo;t generally have to worry about deciding how much memory to allocate. The <code>Vec</code> picks some small, reasonable minimum, then just doubles in size each time it needs more memory. This has the nice properties that reallocations are rare<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and you never waste too much space.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>What if we took a similar approach and made each chunk twice the size of the last one? We would only need need \(O(\log n)\) chunks rather than \(O(n)\), saving lots of allocations and getting better cache behavior as the chunks get bigger. This is the best of both worlds: small lists only waste a small amount of data, but big lists benefit from big chunks.</p><h1 id=what-needs-to-change>What needs to change?</h1><p>The code from the last post will <em>almost</em> work. All of the translation from indices to chunk IDs is done by three functions:</p><ul><li><code>chunk_size</code>, which determines the size of the chunk based on its ID</li><li><code>chunk_start</code>, which determines the first index contained based on a chunk&rsquo;s ID</li><li><code>index_chunk</code>, which determines the chunk ID that contains a particular index</li></ul><p>Everything else can remain exactly the same. We just need to make sure that those few functions work exactly as expected. In particular, we need to make sure that a few things are true for every possible input:</p><ul><li>Each chunk starts where the last one ends<ul><li><code>chunk_start(n) + chunk_size(n) == chunk_start(n + 1)</code></li></ul></li><li>Each index is contained within its chunk<ul><li><code>chunk_start(index_chunk(i)) &lt;= i</code> and also</li><li><code>chunk_start(index_chunk(i)) + chunk_size(index_chunk(i)) > i</code></li></ul></li><li>The first chunk starts at index 0<ul><li><code>chunk_start(0) == 0</code></li></ul></li><li>All chunks have a strictly positive size<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup><ul><li><code>chunk_size(n) > 0</code></li></ul></li></ul><p>We can make each one into a test. If these tests pass, we can be fairly confident that the whole module works and is safe.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> You can check out the tests (they&rsquo;re not particularly interesting) <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a83b41ba347bb07a6732463240761e44">in the Rust Playground</a>, and we can quickly verify that they pass using the uniform-sized chunk code we implemented last time.</p><pre><code>running 5 tests
test test::chunks_start_where_last_ended ... ok
test test::all_chunks_have_positive_size ... ok
test test::first_chunk_starts_at_0 ... ok
test test::thousand_items ... ok
test test::index_in_correct_chunk ... ok
</code></pre><h1 id=implementing-chunk_size>Implementing <code>chunk_size</code></h1><p>Each chunk is twice the size of the previous one, except that the first chunk is <code>FIRST_CHUNK_SIZE</code>. Flipping that around, each chunk will be the first chunk size doubled <code>chunk_id</code> times. Because we&rsquo;re dealing with unsigned integers, a bitwise left shift by 1 (<code>&lt;&lt; 1</code> in Rust) doubles a value once, a shift by 2 doubles it twice, and a shift by \(n\) doubles it \(n\) times. Essentially, we&rsquo;re exploiting the fact that calculating powers of 2 in binary is as easy as calculating powers of 10 in decimal: just shift everything a few places! This makes <code>chunk_size</code> very simple:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>chunk_size</span>(chunk_id: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    FIRST_CHUNK_SIZE <span style=color:#f92672>&lt;&lt;</span> chunk_id;
}
</code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f0d7d209eb672c80b3d98467820cc668">Playground</a></p><p>Let&rsquo;s try it&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>test test::chunks_start_where_last_ended ... FAILED
</code></pre></div><p>Of course, it failed because <code>chunk_size</code> and <code>chunk_start</code> no longer match up.</p><h1 id=implementing-chunk_start>Implementing <code>chunk_start</code></h1><p>Figuring out where a chunk starts is equivalent to figuring out the total number of items in all preceding chunks. We could loop through the list of chunks, adding up each one&rsquo;s size to get the starting position of the next one. But is there a faster way?</p><p>Lets look at some example values when the <code>FIRST_CHUNK_SIZE</code> is 16.</p><table><thead><tr><th>Chunk ID</th><th>Size</th><th>Start</th></tr></thead><tbody><tr><td>0</td><td>16</td><td>0</td></tr><tr><td>1</td><td>32</td><td>16</td></tr><tr><td>2</td><td>64</td><td>48 (16 + 32)</td></tr><tr><td>3</td><td>128</td><td>112 (16 + 32 + 64)</td></tr></tbody></table><p>A pattern! Each chunk starts at its own length minus the length of the first chunk. It turns out that that is holds for any <code>FIRST_CHUNK_SIZE</code> as long as the chunk sizes are doubling. Check out this footnote for a not-particularly-satisfying explanation.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><p>Happily, the actual code is super easy to write.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>chunk_start</span>(chunk_id: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    chunk_size(chunk_id) <span style=color:#f92672>-</span> FIRST_CHUNK_SIZE;
}
</code></pre></div><pre><code>test test::chunks_start_where_last_ended ... ok
test test::index_in_correct_chunk ... FAILED
</code></pre><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=fece3065862917d11369df5bbf3a83e2">Playground</a></p><p>Better! But still not there yet. Chunk starts and sizes line up with each other, but not indices.</p><h1 id=implementing-index_chunk>Implementing <code>index_chunk</code></h1><p>This is definitely the hardest one.</p><p>The chunk starting positions are an exponential function. We want the inverse of that function, which means we&rsquo;ll have to deal with some logarithms.</p><p>The functions we wrote for chunk size that we used before can be expressed as mathematical formulas. If the first chunk has size \(C\) and we care about chunk \(n\), the chunk has size \(C \times 2^n\) and it begins at index \(C \times 2^n - C\).</p><p>If we pick an index \(i\), we can figure out which chunk it should go in by setting \(i\) equal to the starting position of the chunk and solving for the chunk number. In general, the result we get is not an integer, but we know the chunk number is always an integer. We will have to round down because any index occuring partway through a chunk has the same chunk number as the beginning of the chunk.</p><p>The algebra isn&rsquo;t actually <strong>that</strong> bad. We want to find the chunk \(n\) corresponding to index \(i\), so we set \(i\) equal to the chunk
start formula.</p><span>$$ i = C \times 2^n - C $$</span><p>Now factor out \(C\) and solve for \(2^n\).</p><span>$$ i = C \times (2^n - 1) $$</span>
<span>$$ \frac{i}{C} = 2^n - 1 $$</span>
<span>$$ \frac{i}{C} + 1 = 2^n $$</span>
<span>$$ \frac{i + C}{C} = 2^n $$</span><p>And then just take \(\log_2\) of both sides and simplify.</p><span>$$ \log_2{\frac{i + C}{C}} = \log_2{2^n} $$</span>
<span>$$ \log_2{(i + C)} - \log_2{C} = n $$</span><p>For any index that isn&rsquo;t the first index of a chunk, this formula will give you a fractional value for \(n\), the chunk ID. Like we said, fractional value should be rounded down, so the actual equation is the floor (rounded down value, \(\lfloor x \rfloor\)) of what we got before.</p><span>$$ \lfloor \log_2{(i + C)} - \log_2{C} \rfloor = n $$</span><p>Now, if we can guarantee that \(C\) is a power of 2 (and we can, we can set the first chunk size to any value), we break this down even further. This is allowed because if \(C\) is a power of 2, \(\log_2{C}\) will always be an integer, so it no longer matters if it gets rounded or not.</p><span>$$ \lfloor \log_2{(i + C)} \rfloor - \log_2{C} = n $$</span><p>After all that, it&rsquo;s as simple as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index_chunk</span>(index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    floor_log2(index <span style=color:#f92672>+</span> FIRST_CHUNK_SIZE) <span style=color:#f92672>-</span> floor_log2(FIRST_CHUNK_SIZE)
}
</code></pre></div><p>Unfortunately, there&rsquo;s no direct <code>floor_log2</code> implementation on <code>usize</code>, but the standard library does have <a href=https://doc.rust-lang.org/std/primitive.usize.html><code>usize::leading_zeros()</code></a>, which gives the number of leading zeroes in the binary representation of a <code>usize</code>. This is actually pretty close to what we&rsquo;re looking for: a nonzero number \(x\) needs \( \lfloor 1 + \log_2 x \rfloor \) bits to be represented in binary, and the rest of the digits will be zeroes. So all we need to do is get the number of bits in the whole representation, then subtract the number of leading zero bits (and that extra 1).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[inline]</span>
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>floor_log2</span>(x: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#66d9ef>const</span> BITS_PER_BYTE: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;

    BITS_PER_BYTE <span style=color:#f92672>*</span> std::mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>-</span> (x.leading_zeros() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
}
</code></pre></div><p>This one gets marked as <code>#[inline]</code> and <code>const</code> to help the compiler out in debug builds. <code>BITS_PER_BYTE</code> feels like it should be defined somewhere in <code>core</code> or <code>std</code>, but it somehow isn&rsquo;t. (Edit: <a href=https://doc.rust-lang.org/std/primitive.usize.html#associatedconstant.BITS><code>usize::BITS</code></a> is now an experimental API.)</p><h1 id=and-thats-everything>And that&rsquo;s everything!</h1><p>If you put all the code from the last two posts together, you end up essentially with the <a href=https://crates.io/crates/appendlist>appendlist</a> crate.</p><p>The last question: is this data structure useful for anything? It&rsquo;s fairly niche. In general, you&rsquo;d do better to store all of your objects in a <code>Vec</code> and keep track of the index to each one, just eating the resizing costs. If resizing is expensive, that might be a use case for a specialized linked list. If you can come up with a use for this data structure, <a href=/about/>let me know</a>, I&rsquo;d love to hear about it!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The runtime cost could be lower, except that Rust still hasn&rsquo;t stabilized <a href=https://github.com/rust-lang/rfcs/issues/2424>const generics</a>, which would embed the chunk size information into the type. (Edit: These were stabilized in <a href=https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html>Rust 1.51</a>)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Specifically, storing \(n\) elements requires \(O(\log n)\) allocations, letting you amortize the occasional reallocation over the large number of elements and essentially acting like insertions are constant-time, even though they occasionally aren&rsquo;t.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>In the worst case (immediately after reallocating) storing \(n\) elements wastes \(O(n)\) elements worth of space. In the best case, immediately before reallocating, no space is wasted.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>This is required based on the implementation of <code>push</code> from last time. You could imagine an alternate <code>push</code> implementation that allows zero-sized chunks, but it doesn&rsquo;t have practical value: a zero-sized chunk incurs some overhead without storing anything. Also, you would need to add a requirement in that case that more chunks eventually result in a longer list. For example, maybe that that the limit of <code>chunk_start</code> is unbounded as \(n \rightarrow \infty\). Of course, using <code>usize</code> means that there will never be negatives.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>I mean, somebody could do something nasty with global state that would make the tests pass but be incorrect, but any three pure functions that satisfy these rules will work. This is where functional programming can really shine.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>Because each chunk doubles the last one, it has just about the same size as all of the previous chunks added together. Imagine lining up each previous chunk next to the current chunk. For example, looking at chunk 3: it&rsquo;s 128 items long. Chunk 2 takes up takes up half of it with 64 items, chunk 1 takes up half of what remains with 32, and chunk 0 takes up half of whats left with 16. But there are 16 items unaccounted for. In a mathematical series, we would keep going: chunk -1 takes up half the slack with 8, then chunk -2, -3, -4, and so on, eventually finding that the infinite series converges to take up the full size. But we don&rsquo;t actually have these &ldquo;negative&rdquo; chunks! Instead, we just subtract the total size of all of those &ldquo;negative&rdquo; chunks from the size to get the starting position, and the negative chunks' total size is exactly the same as the <code>FIRST_CHUNK_SIZE</code>. This is kinda strange and not at all what I expected, so if you have a more intuitive explanation, I&rsquo;d love to hear about it.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><footer></footer></body></html>