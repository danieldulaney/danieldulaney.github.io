<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Interior Mutability in Rust using UnsafeCell (Part 1) | Daniel Dulaney</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/tags/>Tags</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Interior Mutability in Rust using UnsafeCell (Part 1)</span></h1><h2 class=date>2019/07/13</h2></div><main><p>Rust&rsquo;s borrow checker is a powerful tool. It makes sure your code is safe by enforcing two rules:</p><ol><li>Multiple immutable references or one mutable reference at a time, but not both.</li><li>References must always be valid.</li></ol><p>Pretty much everyone who writes Rust has, at some point, tried to do some simple list manipulation&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> list <span style=color:#f92672>=</span> Vec::new();

<span style=color:#75715e>// Add an item, then borrow it
</span><span style=color:#75715e></span>list.push(<span style=color:#ae81ff>1</span>);
<span style=color:#66d9ef>let</span> first_item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>list[<span style=color:#ae81ff>0</span>];

<span style=color:#75715e>// Oh no, we&#39;re modifying the list while it&#39;s borrowed! This fails to compile
</span><span style=color:#75715e></span>list.push(<span style=color:#ae81ff>1</span>);
<span style=color:#66d9ef>let</span> second_item <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>list[<span style=color:#ae81ff>1</span>];

<span style=color:#75715e>// This *feels* like it should work
</span><span style=color:#75715e></span>assert_eq<span style=color:#f92672>!</span>(first_item, second_item);
</code></pre></div><p>&mldr;and felt the wrath of the borrow checker.</p><pre><code>error[E0502]: cannot borrow 'list' as mutable because it is also borrowed as immutable
</code></pre><p>Eventually, you pick up on what the compiler saying and structure your programs to satisfy the borrow checker. But it can sometimes be useful to bend the rules a bit. This post goes into the design of <code>AppendList</code>, a data structure that lets the code above compile using interior mutability, <code>unsafe</code>, and logarithms.</p><h1 id=the-appendlist-interface>The <code>AppendList</code> interface</h1><p>We want a list list that lets you append a new item while you hold references to other items it contains. In addition to creating a new (empty) list, we&rsquo;ll want to do three main things:</p><ul><li>Get an item by index anywhere in the list (we&rsquo;ll return an <code>Option</code> in case
the index is out of bounds)</li><li>Append a single item onto the end of the list</li><li>Get the length of the list</li></ul><p>In code form, it looks something like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppendList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// We&#39;ll discuss this later
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> AppendList<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span>self, item: <span style=color:#a6e22e>T</span>) {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=7437f04738ae847f1e02ff21a70ab032">Rust playground</a></p><p>In an actual release you&rsquo;d probably want to implement <code>Index</code> and <code>Default</code> and maybe even <code>FromIterator</code>, but they&rsquo;re not hard to derive from these.</p><p>The only really interesting one is the <code>push</code> method. It takes an immutable <code>&self</code>, but will have to modify the object. This is called <a href=https://ricardomartins.cc/2016/06/08/interior-mutability>interior mutability</a> because you mutate the data inside a structure even though structure itself is immutable. The most well-known example is probably the <a href=https://doc.rust-lang.org/std/cell/struct.Cell.html#method.set><code>std::cell::Cell::set</code> method</a>, which has exactly the same signature as <code>push</code>.</p><p>We want this because it lets us call <code>push</code> even when there are other references to the data structure.</p><p>By the way, this doesn&rsquo;t fix the separate issue of references to some <code>Vec</code> elements interfering with access to other <code>Vec</code> elements. This is safe, but the borrow checker isn&rsquo;t smart enough to recognize it. You can solve it in a <code>Vec</code> specifically <a href=https://stackoverflow.com/questions/30073684>using <code>split_at_mut</code></a>. This post only deals with pushing new elements onto the <code>Vec</code> as a whole, which even <code>split_at_mut</code> doesn&rsquo;t help with.</p><h1 id=the-three-approaches-to-interior-mutability>The three approaches to interior mutability</h1><p>Basically, the standard library has three tools that provide interior mutability:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><ul><li><a href=https://doc.rust-lang.org/std/cell/struct.Cell.html><code>Cell</code></a></li><li><a href=https://doc.rust-lang.org/std/cell/struct.RefCell.html><code>RefCell</code></a></li><li><a href=https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html><code>UnsafeCell</code></a></li></ul><p><code>Cell</code> is a hunk of memory that you can change through an immutable reference, but only if you make sure that it always holds valid data. In practice, this means that you can only swap values in and out, not edit the value in place. Also, you can&rsquo;t get an immutable reference to its contents, so it won&rsquo;t be enough for us.</p><p><code>RefCell</code> is a chunk of memory whose ownership is checked at runtime. Normally Rust does compile-time checking, but <code>RefCell</code> keeps track of how many references to it exist at runtime and decides whether to allow mutation based on the normal rules (either one mutable or multiple immutable references, but not both). The runtime checks are useful for some data structures (like linked lists), but come with a runtime cost. It also doesn&rsquo;t allow simple references to its contents &ndash; you
need to use its <a href=https://doc.rust-lang.org/std/cell/struct.Ref.html>special reference type</a> (or its <a href=https://doc.rust-lang.org/std/cell/struct.RefMut.html>mutable variant</a>).</p><p><code>UnsafeCell</code> is the core interior mutability primitive. Both <code>Cell</code> and <code>RefCell</code> are implemented using it under the hood, and it is the most powerful of the three. However, it can only be used with <code>unsafe</code> code, so misusing it will compromise Rust&rsquo;s memory safety guarantees (as we&rsquo;ll see). It&rsquo;s up to the programmer to make sure that any mutations don&rsquo;t end up causing problems.</p><p>Unfortunately, we&rsquo;re stuck using <code>UnsafeCell</code>. <code>Cell</code> doesn&rsquo;t allow non-<code>mut</code> references, which we need in order to implement <code>get</code>. <code>RefCell</code> has a run-time cost and can&rsquo;t handle mutations while non-<code>mut</code> references are out there.</p><h1 id=a-bad-approach-just-use-unsafecellvec>A bad approach: Just use <code>UnsafeCell&lt;Vec></code></h1><p>Looking at the API, it just about matches up with the ubiquitous <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html><code>std::vec::Vec</code></a>! The only issue is that <code>Vec</code> doesn&rsquo;t have interior mutability. But we have access to an interior mutability primitive in <code>UnsafeCell</code>. What if we just used that?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppendList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    data: <span style=color:#a6e22e>UnsafeCell</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> AppendList<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
        Self {
            data: <span style=color:#a6e22e>UnsafeCell</span>::default(),
        }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>unsafe</span> { (<span style=color:#f92672>*</span>self.data.get()).get(index) }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span>self, item: <span style=color:#a6e22e>T</span>) {
        <span style=color:#66d9ef>unsafe</span> { (<span style=color:#f92672>*</span>self.data.get()).push(item) }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        <span style=color:#66d9ef>unsafe</span> { (<span style=color:#f92672>*</span>self.data.get()).len() }
    }
}
</code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=253a1f026bd3ed0db13fe6005bce7be9">Rust Playground</a></p><p>That was easy! Each function is just a thin wrapper over the underlying <code>Vec</code>, which makes the code super simple. The standard pattern is <code>(\*self.data.get())</code>. The call to <code>get()</code> pulls out a raw pointer to the underlying <code>Vec</code>, then <code>*</code> dereferences it, and the whole thing is wrapped in <code>unsafe</code> because we&rsquo;re dereferencing a raw pointer.</p><p>So let&rsquo;s run the test in the playground!</p><pre><code> thread 'test::thousand_items' panicked at 'assertion failed: `(left == right)`
  left: `Some(139954529247456)`,
 right: `Some(128)`', src/lib.rs:51:13
</code></pre><p>Well that&rsquo;s not great. Where did that huge number come from? Let&rsquo;s try that again.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><pre><code>thread 'test::thousand_items' panicked at 'assertion failed: `(left == right)`
  left: `Some(140315306500320)`,
 right: `Some(128)`', src/lib.rs:51:13
</code></pre><p>Oh no.</p><p>The number changed. That&rsquo;s because that number is in uninitialized memory. Somehow our implementation violated Rust&rsquo;s memory rules, so the safe code in the test function is dereferencing invalid memory. This approach is deeply broken. But why?</p><h1 id=why-the-first-approach-is-deeply-broken>Why the first approach is deeply broken</h1><p>To understand the issue you have to know something about how a <code>Vec</code> works. A <code>Vec</code> stores three values: a pointer to a buffer, the capacity of that buffer, and the number of slots actually in use.</p><p>When you call <code>vec![1, 2, 3]</code>, you end up with a three-field struct (a pointer, a length, and a capacity). The pointer points to a buffer, which can hold up to the capacity&rsquo;s worth of elements. The length keeps track of how much of the buffer is used.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p><img src=images/diagram-1.drawio.svg alt="Basic vector internal structure"></p><p>The first block of memory is put wherever you allocated your <code>Vec</code> (in our case, it&rsquo;s a part of the <code>AppendList</code> data layout), and it won&rsquo;t ever change size. The second block of memory is on the heap, and it will be reallocated whenever the length of the list is about to exceed the capacity of the memory block.</p><p>When a reallocation happens, a new chunk of memory is allocated and all the data is copied over. Then the existing chunk of memory is freed.</p><p>For example, when we insert our 4th item, the <code>Vec</code> will allocate double the space, copy over the data, and free the old buffer.</p><p><img src=images/diagram-2.drawio.svg alt="Vector after reallocation"></p><p>But what if there are references into the <code>Vec</code>? They are essentially pointers directly into the buffer. When the buffer is reallocated, any references have no idea that anything has changed &ndash; they will point into the old already-freed buffer and using them in any way can cause a use-after-free error.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><p>Of course, Rust prevents this by default: if you have any references into a <code>Vec</code>, you aren&rsquo;t allowed to mutate it. But we&rsquo;ve completely broken
that protection! By allowing a <code>push</code> while there are references out there, we open ourselves up to use-after-free bugs. We need a better approach.</p><h1 id=a-better-approach-a-list-of-chunks>A better approach: A list of chunks</h1><p>Our main issue is that reallocation invalidates all references to that buffer. We need to find a way to allocate new data <strong>without</strong> reallocating. One approach is to use a list of constant-size chunks. Whenever we run out of space, we allocate a new chunk, never letting a particular chunk reallocate. We then have a list of chunks, with each one full except for the last one.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppendList</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    chunks: <span style=color:#a6e22e>UnsafeCell</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;&gt;</span>,
}
</code></pre></div><p>Now we have a dynamically-sized list of chunks, each of which is some size. For example, let&rsquo;s pretend we are storing the values 1, 2, 3, 4, and 5 using chunks with length 3. The outer <code>Vec</code> points to a buffer containing several <code>Vec</code> headers, each of which has capacity 3.</p><p><img src=images/diagram-3.drawio.svg alt="Constant-size chunk diagram"></p><p>The &ldquo;Uninit&rdquo; item is a piece of uninitialized memory. When a new value gets pushed, it gets placed there and the second chunk&rsquo;s length field is updated.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>If a second new value is pushed, a new chunk needs to be added. Because there isn&rsquo;t room in the list of chunks, it will have to be reallocated. However, the actual data itself won&rsquo;t move, so any references (like <code>&list[1]</code>) stay valid.</p><p><img src=images/diagram-4.drawio.svg alt="Constant-size chunk diagram after inserting 6 and 7"></p><p>This structure fixes the invalid references issue.
But how will we implement <code>get</code>, <code>push</code>, and <code>len</code>?
Really, we just need to be able to calculate 3 things:</p><ul><li>For any particular chunk, how many values does it hold?</li><li>For any particular chunk, what is the first index it holds?</li><li>Which chunk is a particular index in?</li></ul><p>We can make each of these into a small utility function. The <code>chunk_id</code> is just the index of a particular chunk in the upper <code>Vec</code>, and <code>index</code> is the position of a particular value in the data structure as a whole. For now, each chunk will be a constant size, so it is simple to determine where it begins and which chunk holds an index.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>const</span> CHUNK_SIZE: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>; <span style=color:#75715e>// We&#39;ll discuss this
</span><span style=color:#75715e></span>
<span style=color:#e6db74>/// How big is the given chunk?
</span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>chunk_size</span>(_chunk_id: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#75715e>// Constant for now
</span><span style=color:#75715e></span>    CHUNK_SIZE
}

<span style=color:#e6db74>/// Where does the given chunk start?
</span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>chunk_start</span>(chunk_id: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#75715e>// Chunk 0 starts at index 0, then we go up from there
</span><span style=color:#75715e></span>    CHUNK_SIZE <span style=color:#f92672>*</span> chunk_id
}

<span style=color:#e6db74>/// Which chunk does a particular index belong to?
</span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index_chunk</span>(index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#75715e>// Division rounds down, so this works for any nonzero CHUNK_SIZE
</span><span style=color:#75715e></span>    index <span style=color:#f92672>/</span> CHUNK_SIZE
}
</code></pre></div><p>With these utility functions, <code>get()</code> isn&rsquo;t too complex: just figure out which chunk contains the index of interest, then figure out where it is in that chunk. We end up using pretty much the same pattern as the bad example, where we use <code>unsafe</code> to reach inside the <code>UnsafeCell</code>. The <code>and_then</code> closure is just to appropriately handle the case where the user requests data from a chunk that doesn&rsquo;t exist yet &ndash; it only gets called if <code>get(chunk_id)</code> returns <code>Some</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> chunk_id <span style=color:#f92672>=</span> index_chunk(index);
    <span style=color:#66d9ef>let</span> location <span style=color:#f92672>=</span> index <span style=color:#f92672>-</span> chunk_start(chunk_id);

    <span style=color:#75715e>// Let Vec take care of the bounds checking for us
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>self.chunks.get()) }
        .get(chunk_id)
        .and_then(<span style=color:#f92672>|</span>chunk<span style=color:#f92672>|</span> chunk.get(location))
}
</code></pre></div><p>The length is a little more complex because we have to special-case a completely empty list. Otherwise, you can just figure out where the last chunk starts and add on the number of things it has to get the overall length.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><p>Also, this is the only time I&rsquo;ll bring up thread safety in this post, but <code>len()</code> is a good example of why <code>UnsafeCell</code> automatically makes anything that contains it not <code>Sync</code> &ndash; we hang on to a <code>chunks</code> reference throughout this method, and if some other thread was able to modify the interior of the <code>UnsafeCell</code> it could invalidate that reference.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#66d9ef>let</span> chunks <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;</span>(<span style=color:#f92672>*</span>self.chunks.get()) };
    
    <span style=color:#66d9ef>match</span> chunks.last() {
        <span style=color:#75715e>// No last chunk -&gt; empty data structure
</span><span style=color:#75715e></span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#ae81ff>0</span>,
        
        <span style=color:#75715e>// Start of the last chunk + # of items in it
</span><span style=color:#75715e></span>        Some(last) <span style=color:#f92672>=&gt;</span> chunk_start(chunks.len() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> last.len(),
    }
}
</code></pre></div><p>Pushing a value is a bit more complex, but it&rsquo;s not <strong>too</strong> bad. There are two scenarios to consider:</p><ul><li>We still have room in the current chunk</li><li>We&rsquo;ve run out of room and need to create a new chunk</li></ul><p>It&rsquo;s critical that the new chunk is initialized with the correct capacity. If it doesn&rsquo;t have enough capacity, it will be reallocated in a future <code>push</code> and we&rsquo;ll run into the same memory safety issues as before.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span>self, item: <span style=color:#a6e22e>T</span>) {
    <span style=color:#75715e>// Get a *mutable* reference to the chunk list
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> chunks_mut <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> (<span style=color:#f92672>*</span>self.chunks.get()) };

    <span style=color:#75715e>// Where will we be inserting?
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Note: len() handles the empty case for us
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> new_index <span style=color:#f92672>=</span> self.len();
    
    <span style=color:#75715e>// Which chunk will we be inserting into?
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> chunk_id <span style=color:#f92672>=</span> index_chunk(new_index);
    
    <span style=color:#66d9ef>if</span> chunk_id <span style=color:#f92672>&lt;</span> chunks_mut.len() {
        <span style=color:#75715e>// Still room in the last chunk: just `push` it on
</span><span style=color:#75715e></span>        chunks_mut[chunk_id].push(item);
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#75715e>// We need a new chunk
</span><span style=color:#75715e></span>        
        <span style=color:#75715e>// Create a new chunk with its full capacity but only holding one value
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> new_chunk <span style=color:#f92672>=</span> Vec::with_capacity(chunk_size(chunk_id));
        new_chunk.push(item);
        
        <span style=color:#75715e>// Add it to the list of chunks
</span><span style=color:#75715e></span>        chunks_mut.push(new_chunk);
    }
}
</code></pre></div><p>Ok, that was a lot of code. <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=65502589c22ce9d70808e430aea9ad9c">Check it out in the Rust Playground</a> with the test that gave us trouble before:</p><pre><code>running 1 test
test test::thousand_items ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Excellent! We&rsquo;ve written a data structure that lets us freely index into a list and push new elements into it using one of Rust&rsquo;s advanced primitives.</p><p>But there are still some questions left: What&rsquo;s up with that constant chunk size of 16? What about those logarithms I promised? Why is <code>chunk_size</code> a function?</p><p>Those questions will have to wait for <a href=../arraylist-part-2/>part 2</a>, where we look at another way to determine chunk sizes and dig up some formulas from your (or at least my) high-school math class.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Three single-threaded tools. There&rsquo;s quite a few other tools for threaded code (e.g. <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html><code>Mutex</code></a>).&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>This is undefined behavior, so you might get a different number, a hang, or a crash, and it&rsquo;s hard to predict which. Fun!&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><code>Vec</code> only guarantees that it allocates <strong>at least</strong> enough space to fit all the elements, so the capacity might be higher than 3 in this example.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Rust is a safe language, but remember that we used <code>unsafe</code> in this module, which means that <em>all</em> the module&rsquo;s code is potentially tainted. A well-written module will guarantee that there is no way to use the publically-accessable API in an unsafe way, but even safe code in this module needs to be audited for safety. For more on this boundary, check out Jason Orendorff&rsquo;s talk <a href="https://www.youtube.com/watch?v=rTo2u13lVcQ">&ldquo;Building on an unsafe foundation&rdquo;</a> and <a href=https://doc.rust-lang.org/nomicon/working-with-unsafe.html>Section 1.3</a> of
<a href=https://doc.rust-lang.org/nomicon/README.html>The Rustonomicon</a>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Which, of course, is handled for us by the <code>Vec</code> implementation. This is why we&rsquo;re using <code>Vec&lt;T></code> instead of boxed slices ( <code>Box&lt;[T]></code> ) &ndash; boxed slices would require us to do the bookkeeping around the uninitialized values ourselves.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>You could also figure out the end of the last chunk and subtract the number of empty spaces in the previous chunk. There are options.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><footer></footer></body></html>